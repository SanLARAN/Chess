<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Шахматы с картами</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f5f5f5;
      margin: 0;
      padding: 20px;
    }
    h1, h3 {
      text-align: center;
      color: #333;
    }
    #gameContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #boardContainer {
      margin-bottom: 20px;
    }
    table {
      border-collapse: collapse;
    }
    td {
      width: 60px;
      height: 60px;
      text-align: center;
      vertical-align: middle;
      border: 1px solid #333;
      font-size: 18px;
      cursor: pointer;
      position: relative;
      transition: outline 0.2s ease;
    }
    #handContainer {
      margin-bottom: 20px;
    }
    #handContainer button {
      margin: 5px;
      padding: 8px 12px;
      font-size: 14px;
      cursor: pointer;
    }
    #statusContainer, #logContainer {
      width: 80%;
      max-width: 600px;
      margin-bottom: 10px;
      background-color: #fff;
      padding: 10px;
      border: 1px solid #aaa;
    }
    #logContainer {
      height: 150px;
      overflow-y: auto;
      font-size: 14px;
    }
    .selected {
      outline: 3px solid green !important;
    }
    .move-hint {
      outline: 2px solid blue !important;
    }
  </style>
</head>
<body>
  <h1>Шахматы с картами</h1>
  <div id="gameContainer">
    <div id="statusContainer"></div>
    <div id="boardContainer"></div>
    <div id="handContainer"></div>
    <div id="logContainer"></div>
  </div>
  
  <script>
    // ================== Функции для подсказок и логирования ==================
    function logMessage(msg) {
      const logDiv = document.getElementById("logContainer");
      const p = document.createElement("p");
      p.innerText = msg;
      logDiv.appendChild(p);
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    // Позволяет добавить класс highlight с заданым типом (selected или move-hint)
    function highlightCell(x, y, type) {
      const cell = document.getElementById(`cell-${x}-${y}`);
      if (cell) {
        cell.classList.add(type);
      }
    }

    function clearHighlights() {
      for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
          const cell = document.getElementById(`cell-${x}-${y}`);
          if (cell) {
            cell.classList.remove("selected");
            cell.classList.remove("move-hint");
          }
        }
      }
    }

    // ================== Функции шахматной логики ==================
    // Допустимые ходы для пешки
    function getPawnMoves(piece, board) {
      let moves = [];
      let direction = (piece.player.id === 1) ? -1 : 1;
      let startRow = (piece.player.id === 1) ? 6 : 1;
      let x = piece.position.x, y = piece.position.y;
      // Прямой ход: на одну клетку если пусто
      let ny = y + direction;
      if (ny >= 0 && ny < 8 && board.grid[ny][x] === null) {
        moves.push({x: x, y: ny});
        // Двойной ход, если на старте
        if (y === startRow) {
          let ny2 = y + (2 * direction);
          if (ny2 >= 0 && ny2 < 8 && board.grid[ny2][x] === null) {
            moves.push({x: x, y: ny2});
          }
        }
      }
      // Взятие фигур по диагонали
      for (let dx of [-1, 1]) {
        let nx = x + dx;
        if (nx >= 0 && nx < 8 && ny >= 0 && ny < 8) {
          let target = board.grid[ny][nx];
          if (target !== null && target.player.id !== piece.player.id) {
            moves.push({x: nx, y: ny});
          }
        }
      }
      return moves;
    }

    // Ходы для коня
    function getKnightMoves(piece, board) {
      let moves = [];
      const directions = [
        {dx: 2, dy: 1}, {dx: 2, dy: -1},
        {dx: -2, dy: 1}, {dx: -2, dy: -1},
        {dx: 1, dy: 2}, {dx: -1, dy: 2},
        {dx: 1, dy: -2}, {dx: -1, dy: -2}
      ];
      let {x, y} = piece.position;
      directions.forEach(d => {
        let nx = x + d.dx, ny = y + d.dy;
        if (nx >= 0 && nx < 8 && ny >= 0 && ny < 8) {
          let target = board.grid[ny][nx];
          if (target === null || target.player.id !== piece.player.id) {
            moves.push({x: nx, y: ny});
          }
        }
      });
      return moves;
    }

    // Ходы для ладьи
    function getRookMoves(piece, board) {
      let moves = [];
      const directions = [{dx:1,dy:0}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:0,dy:-1}];
      let {x, y} = piece.position;
      directions.forEach(d => {
        let nx = x, ny = y;
        while (true) {
          nx += d.dx;
          ny += d.dy;
          if (nx < 0 || nx >= 8 || ny < 0 || ny >= 8) break;
          let target = board.grid[ny][nx];
          if (target === null) {
            moves.push({x: nx, y: ny});
          } else {
            if (target.player.id !== piece.player.id) moves.push({x: nx, y: ny});
            break;
          }
        }
      });
      return moves;
    }

    // Ходы для слона (диагональ)
    function getBishopMoves(piece, board) {
      let moves = [];
      const directions = [{dx:1,dy:1}, {dx:1,dy:-1}, {dx:-1,dy:1}, {dx:-1,dy:-1}];
      let {x, y} = piece.position;
      directions.forEach(d => {
        let nx = x, ny = y;
        while (true) {
          nx += d.dx;
          ny += d.dy;
          if (nx < 0 || nx >= 8 || ny < 0 || ny >= 8) break;
          let target = board.grid[ny][nx];
          if (target === null) {
            moves.push({x: nx, y: ny});
          } else {
            if (target.player.id !== piece.player.id) moves.push({x: nx, y: ny});
            break;
          }
        }
      });
      return moves;
    }

    // Ходы для ферзя – сочетание ладьи и слона
    function getQueenMoves(piece, board) {
      return getRookMoves(piece, board).concat(getBishopMoves(piece, board));
    }

    // Ходы для короля – на одну клетку в любом направлении (без рокировки)
    function getKingMoves(piece, board) {
      let moves = [];
      const directions = [
        {dx: 1, dy:0}, {dx:-1, dy:0}, {dx:0, dy:1}, {dx:0, dy:-1},
        {dx: 1, dy: 1}, {dx: 1, dy: -1}, {dx: -1, dy: 1}, {dx: -1, dy: -1}
      ];
      let {x, y} = piece.position;
      directions.forEach(d => {
        let nx = x + d.dx, ny = y + d.dy;
        if (nx >= 0 && nx < 8 && ny >= 0 && ny < 8) {
          let target = board.grid[ny][nx];
          if (target === null || target.player.id !== piece.player.id) {
            moves.push({x: nx, y: ny});
          }
        }
      });
      return moves;
    }

    // Общая функция для получения допустимых ходов фигуры
    function getValidMoves(piece, board) {
      if (!piece) return [];
      switch(piece.type) {
        case "Pawn":
          return getPawnMoves(piece, board);
        case "Knight":
          return getKnightMoves(piece, board);
        case "Bishop":
          return getBishopMoves(piece, board);
        case "Rook":
          return getRookMoves(piece, board);
        case "Queen":
          return getQueenMoves(piece, board);
        case "King":
          return getKingMoves(piece, board);
        default:
          return [];
      }
    }

    // ================== Карточная логика ==================
    // Класс карты с описанием
    class Card {
      constructor(name, rarity, description, effect) {
        this.name = name;
        this.rarity = rarity;
        this.description = description;
        this.effect = effect; // Функция (game, player, target)
      }

      use(game, player, target) {
        logMessage(`${player.name} использует карту: ${this.name}`);
        this.effect(game, player, target);
      }
    }

    // Определяем 15 карт с эффектами и описаниями
    const cardPool = [
      new Card("Стальной Щит", "Обычная", "Защищает выбранную фигуру от захвата на один ход.", (game, player, target) => {
          if (target) {
             target.shield = true;
             logMessage(`Фигура ${target.type} теперь под защитой на один ход.`);
          } else {
             logMessage("Не выбрана цель для «Стального Щита».");
          }
      }),
      new Card("Ветер Перемен", "Обычная", "Дает дополнительный ход.", (game, player, target) => {
          logMessage("Используется «Ветер Перемен»: игрок получает дополнительный ход.");
          // Дополнительный ход: оставляем текущего игрока
          game.currentPlayerIndex = game.players.indexOf(player);
      }),
      new Card("Острый Клинок", "Обычная", "Мгновенно захватывает вражескую фигуру.", (game, player, target) => {
          if (target && target.player !== player) {
             logMessage(`«Острым Клинком» удалена фигура ${target.type} противника.`);
             let pos = target.position;
             game.board.grid[pos.y][pos.x] = null;
          } else {
             logMessage("Нет подходящей цели для «Острого Клинка».");
          }
      }),
      new Card("Теневой Манёвр", "Редкая", "Скрывает выбранную фигуру от противника на один ход.", (game, player, target) => {
          if (target && target.player === player) {
              target.invisible = true;
              logMessage(`Фигура ${target.type} становится невидимой на один ход.`);
          } else {
              logMessage("Цель должна принадлежать игроку для «Теневого Манёвра».");
          }
      }),
      new Card("Эхо Возмездия", "Редкая", "При следующем захвате позволяет восстановить фигуру (заглушка).", (game, player, target) => {
          logMessage("«Эхо Возмездия» активировано: при следующем захвате фигуры её эффектом можно восстановить фигуру.");
      }),
      new Card("Смена Позиции", "Редкая", "Меняет местами две выбранные фигуры.", (game, player, target) => {
          if (target && target.piece1 && target.piece2) {
             let pos1 = target.piece1.position;
             let pos2 = target.piece2.position;
             game.board.grid[pos1.y][pos1.x] = target.piece2;
             game.board.grid[pos2.y][pos2.x] = target.piece1;
             target.piece1.position = pos2;
             target.piece2.position = pos1;
             logMessage(`Позиции фигур ${target.piece1.type} и ${target.piece2.type} изменены.`);
          } else {
             logMessage("Необходимо выбрать две фигуры для «Смены Позиции».");
          }
      }),
      new Card("Пламенный Взрыв", "Эпическая", "Уничтожает все фигуры вокруг выбранной клетки.", (game, player, target) => {
          if (target) {
             let {x, y} = target.position;
             logMessage(`«Пламенный Взрыв»: уничтожение фигур вокруг (${x}, ${y}).`);
             const directions = [
                {dx: -1, dy: -1}, {dx: 0, dy: -1}, {dx: 1, dy: -1},
                {dx: -1, dy: 0},                {dx: 1, dy: 0},
                {dx: -1, dy: 1},  {dx: 0, dy: 1},  {dx: 1, dy: 1}
             ];
             directions.forEach(dir => {
               let newX = x + dir.dx;
               let newY = y + dir.dy;
               if (newX >= 0 && newX < 8 && newY >= 0 && newY < 8 && game.board.grid[newY][newX] != null) {
                 logMessage(`Фигура ${game.board.grid[newY][newX].type} уничтожена.`);
                 game.board.grid[newY][newX] = null;
               }
             });
          } else {
             logMessage("Не выбрана цель для «Пламенного Взрыва».");
          }
      }),
      new Card("Ледяное Зачарование", "Эпическая", "Замораживает вражескую фигуру на один ход.", (game, player, target) => {
          if (target && target.player !== player) {
             target.frozen = true;
             logMessage(`Фигура ${target.type} заморожена и не сможет двигаться в следующий ход.`);
          } else {
             logMessage("Выберите вражескую фигуру для «Ледяного Зачарования».");
          }
      }),
      new Card("Светлая Аура", "Эпическая", "Укрепляет защиту выбранной фигуры, снижая риск захвата.", (game, player, target) => {
          if (target && target.player === player) {
             logMessage(`Фигура ${target.type} усилена «Светлой Аурой»: шанс захвата снижен.`);
             target.protected = true;
          } else {
             logMessage("Выберите свою фигуру для «Светлой Ауры».");
          }
      }),
      new Card("Вспышка Молнии", "Легендарная", "Мгновенно перемещает выбранную фигуру на любую пустую клетку.", (game, player, target) => {
          if (target && target.piece && target.destination && target.piece.player === player) {
              if (game.board.grid[target.destination.y][target.destination.x] === null) {
                 let pos = target.piece.position;
                 game.board.grid[pos.y][pos.x] = null;
                 game.board.grid[target.destination.y][target.destination.x] = target.piece;
                 target.piece.position = { ...target.destination };
                 logMessage(`«Вспышка Молнии»: фигура ${target.piece.type} перемещена на (${target.destination.x}, ${target.destination.y}).`);
              } else {
                  logMessage("Выбрана занятая клетка для перемещения.");
              }
          } else {
              logMessage("Выберите свою фигуру и затем пустую клетку для «Вспышки Молнии».");
          }
      }),
      new Card("Призыв Фантома", "Легендарная", "Добавляет дополнительную пешку на случайную свободную клетку.", (game, player, target) => {
          logMessage("«Призыв Фантома»: добавление дополнительной пешки на свободную клетку.");
          let freeCells = [];
          for (let y = 0; y < 8; y++) {
            for (let x = 0; x < 8; x++) {
              if (game.board.grid[y][x] === null) {
                freeCells.push({ x, y });
              }
            }
          }
          if (freeCells.length > 0) {
            let cell = freeCells[Math.floor(Math.random() * freeCells.length)];
            let pawn = new Piece("Pawn", player);
            pawn.position = { ...cell };
            game.board.grid[cell.y][cell.x] = pawn;
            logMessage(`Фантом-пешка добавлена на (${cell.x}, ${cell.y}).`);
          } else {
            logMessage("Нет свободной клетки для «Призыва Фантома».");
          }
      }),
      new Card("Темный Вихрь", "Легендарная", "Случайным образом перемещает все фигуры на одну клетку.", (game, player, target) => {
          logMessage("«Темный Вихрь»: случайное перемещение всех фигур на одну клетку.");
          const directions = [
             {dx: -1, dy: 0}, {dx: 1, dy: 0}, {dx: 0, dy: -1}, {dx: 0, dy: 1}
          ];
          for (let y = 0; y < 8; y++) {
            for (let x = 0; x < 8; x++){
              let piece = game.board.grid[y][x];
              if (piece) {
                 let randomDir = directions[Math.floor(Math.random() * directions.length)];
                 let newX = x + randomDir.dx;
                 let newY = y + randomDir.dy;
                 if (newX >= 0 && newX < 8 && newY >= 0 && newY < 8 && game.board.grid[newY][newX] === null) {
                    game.board.grid[newY][newX] = piece;
                    piece.position = { x: newX, y: newY };
                    game.board.grid[y][x] = null;
                    logMessage(`Фигура ${piece.type} перемещена с (${x}, ${y}) на (${newX}, ${newY}).`);
                 }
              }
            }
          }
      }),
      new Card("Коварный Обман", "Редкая", "Отменяет эффект вражеской карты на один ход.", (game, player, target) => {
          logMessage("«Коварный Обман» активирован: отмена эффекта вражеской карты на один ход.");
      }),
      new Card("Магическая Инсталляция", "Эпическая", "Комбинирует две карты для удвоения их эффекта (заглушка).", (game, player, target) => {
          logMessage("«Магическая Инсталляция»: комбинирование двух карт для удвоения эффекта.");
      }),
      new Card("Божественный Суд", "Легендарная", "Сбрасывает все ходы и восстанавливает исходное расположение фигур.", (game, player, target) => {
          logMessage("«Божественный Суд» активирован: восстановление исходного положения фигур.");
          game.board = new Board();
          game.board.setupPieces(game.player1, game.player2);
      })
    ];

    // Функция для выбора случайной карты с учетом веса редкости
    function drawRandomCard() {
      let totalWeight = cardPool.reduce((sum, card) => sum + (card.rarity === "Обычная" ? 50 :
                                                              card.rarity === "Редкая" ? 30 :
                                                              card.rarity === "Эпическая" ? 15 : 5), 0);
      let random = Math.random() * totalWeight;
      for (let card of cardPool) {
        let weight = (card.rarity === "Обычная" ? 50 :
                     card.rarity === "Редкая" ? 30 :
                     card.rarity === "Эпическая" ? 15 : 5);
        random -= weight;
        if (random < 0) {
          return new Card(card.name, card.rarity, card.description, card.effect);
        }
      }
      return new Card(cardPool[cardPool.length - 1].name,
                      cardPool[cardPool.length - 1].rarity,
                      cardPool[cardPool.length - 1].description,
                      cardPool[cardPool.length - 1].effect);
    }

    // ================== Классы игроков, фигур, доски и игры ==================
    class Player {
      constructor(id, name) {
        this.id = id;
        this.name = name;
        this.mmr = 300;
        this.hand = [];
      }
      addCard(card) {
        this.hand.push(card);
        logMessage(`${this.name} получил карту: ${card.name} (${card.rarity})`);
      }
    }

    class Piece {
      constructor(type, player) {
        this.type = type;
        this.player = player;
        this.position = null;
        this.shield = false;
        this.invisible = false;
        this.frozen = false;
        this.protected = false;
      }
    }

    class Board {
      constructor() {
        this.grid = [];
        for (let i = 0; i < 8; i++) {
          this.grid[i] = new Array(8).fill(null);
        }
      }
      setupPieces(player1, player2) {
        const backRank = ["Rook", "Knight", "Bishop", "Queen", "King", "Bishop", "Knight", "Rook"];
        // Игрок 2 (например, чёрные) – верхняя сторона (строки 0 и 1)
        for (let j = 0; j < 8; j++) {
          let piece = new Piece(backRank[j], player2);
          piece.position = { x: j, y: 0 };
          this.grid[0][j] = piece;
        }
        for (let j = 0; j < 8; j++) {
          let piece = new Piece("Pawn", player2);
          piece.position = { x: j, y: 1 };
          this.grid[1][j] = piece;
        }
        // Игрок 1 (например, белые) – нижняя сторона (строки 6 и 7)
        for (let j = 0; j < 8; j++) {
          let piece = new Piece("Pawn", player1);
          piece.position = { x: j, y: 6 };
          this.grid[6][j] = piece;
        }
        for (let j = 0; j < 8; j++) {
          let piece = new Piece(backRank[j], player1);
          piece.position = { x: j, y: 7 };
          this.grid[7][j] = piece;
        }
      }
      // Здесь базовый movePiece – фактически просто перемещает фигуру.
      movePiece(fromX, fromY, toX, toY) {
        let piece = this.grid[fromY][fromX];
        if (!piece) {
          logMessage("Нет фигуры для перемещения!");
          return false;
        }
        let target = this.grid[toY][toX];
        if (target !== null) {
          if (target.player.id === piece.player.id) {
            logMessage("Нельзя захватывать свою фигуру!");
            return false;
          } else {
            if (target.shield) {
              logMessage("Противникская фигура защищена щитом!");
              return false;
            }
            logMessage(`Фигура ${target.type} игрока ${target.player.name} захвачена!`);
            this.grid[toY][toX] = piece;
            this.grid[fromY][fromX] = null;
            piece.position = { x: toX, y: toY };
            return { captured: target };
          }
        } else {
          this.grid[toY][toX] = piece;
          this.grid[fromY][fromX] = null;
          piece.position = { x: toX, y: toY };
          return true;
        }
      }
    }

    class Game {
      constructor(player1, player2) {
        this.player1 = player1;
        this.player2 = player2;
        this.players = [player1, player2];
        this.board = new Board();
        this.board.setupPieces(player1, player2);
        this.currentPlayerIndex = 0;
        this.turns = 0;
      }
      start() {
        logMessage("Игра началась!");
        this.players.forEach(player => {
          for (let i = 0; i < 3; i++) {
            player.addCard(drawRandomCard());
          }
        });
        logMessage(`Ход игрока: ${this.players[this.currentPlayerIndex].name}`);
      }
      nextTurn() {
        this.turns += 1;
        this.players.forEach(player => {
          player.addCard(drawRandomCard());
        });
        this.currentPlayerIndex = (this.currentPlayerIndex + 1) % 2;
        logMessage(`Следующий ход: игрок ${this.players[this.currentPlayerIndex].name}`);
      }
      movePiece(fromX, fromY, toX, toY) {
        let result = this.board.movePiece(fromX, fromY, toX, toY);
        if (result && result.captured) {
          let player = this.players[this.currentPlayerIndex];
          logMessage(`${player.name} получил карту за захват фигуры!`);
          player.addCard(drawRandomCard());
        }
        this.nextTurn();
      }
      useCard(player, cardIndex, target) {
        if (player !== this.players[this.currentPlayerIndex]) {
          logMessage("Не твой ход для использования карты.");
          return;
        }
        if (cardIndex < 0 || cardIndex >= player.hand.length) {
          logMessage("Неверный индекс карты.");
          return;
        }
        let card = player.hand.splice(cardIndex, 1)[0];
        card.use(this, player, target);
        this.nextTurn();
      }
    }

    // ================== UI и логика взаимодействия ==================
    let game;
    let selectedMoveSource = null; // для выбора фигуры и хода
    let selectedCard = null;       // для выбора карты (если требуется выбор цели)
    let selectedCardIndex = -1;
    let cardTargetData = {};       // для карт, которым нужно выбирать две цели

    // Карты, не требующие выбора цели (применяются сразу)
    const cardsWithoutTarget = ["Ветер Перемен", "Эхо Возмездия", "Призыв Фантома", "Темный Вихрь", "Коварный Обман", "Магическая Инсталляция", "Божественный Суд"];

    function createBoardUI() {
      const boardDiv = document.getElementById("boardContainer");
      const table = document.createElement("table");
      table.id = "board";
      for (let y = 0; y < 8; y++) {
        const tr = document.createElement("tr");
        for (let x = 0; x < 8; x++) {
          const td = document.createElement("td");
          td.id = `cell-${x}-${y}`;
          td.style.backgroundColor = ((x + y) % 2 === 0) ? "#eee" : "#999";
          td.addEventListener("click", () => { onBoardCellClick(x, y); });
          tr.appendChild(td);
        }
        table.appendChild(tr);
      }
      boardDiv.innerHTML = "";
      boardDiv.appendChild(table);
    }

    function updateBoardUI() {
      for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
          const cell = document.getElementById(`cell-${x}-${y}`);
          cell.innerHTML = "";
          cell.classList.remove("selected", "move-hint");
          const piece = game.board.grid[y][x];
          if (piece) {
            const pieceDiv = document.createElement("div");
            // Отображаем первую букву типа фигуры
            pieceDiv.innerText = piece.type.charAt(0);
            pieceDiv.style.fontWeight = "bold";
            pieceDiv.style.color = (piece.player.id === 1) ? "red" : "blue";
            cell.appendChild(pieceDiv);
          }
        }
      }
      // Если выбрана фигура для хода, подсвечиваем исходную клетку и допустимые ходы
      if (selectedMoveSource) {
        highlightCell(selectedMoveSource.from.x, selectedMoveSource.from.y, "selected");
        selectedMoveSource.moves.forEach(m => {
          highlightCell(m.x, m.y, "move-hint");
        });
      }
    }

    function updateHandUI() {
      const handDiv = document.getElementById("handContainer");
      handDiv.innerHTML = `<h3>Ваши карты (Ход: ${getCurrentPlayer().name})</h3>`;
      const currentHand = getCurrentPlayer().hand;
      currentHand.forEach((card, index) => {
        const btn = document.createElement("button");
        btn.innerText = `${card.name} (${card.rarity})`;
        // При наведении показываем описание карты
        btn.title = card.description;
        btn.addEventListener("click", () => {
          selectedCard = card;
          selectedCardIndex = index;
          // Если карта не требует выбора цели – применяем сразу
          if (cardsWithoutTarget.includes(card.name)) {
            game.useCard(getCurrentPlayer(), selectedCardIndex, null);
            selectedCard = null;
            updateUI();
          } else {
            logMessage(`Выбрана карта: ${card.name}. Теперь выберите цель на доске.`);
          }
        });
        handDiv.appendChild(btn);
      });
    }

    function updateStatus() {
      const statusDiv = document.getElementById("statusContainer");
      statusDiv.innerHTML = `<strong>Ход: ${getCurrentPlayer().name}</strong> | Раунд: ${game.turns}`;
    }

    function updateUI() {
      updateBoardUI();
      updateHandUI();
      updateStatus();
    }

    function getCurrentPlayer() {
      return game.players[game.currentPlayerIndex];
    }

    // Обработка клика по клетке доски:
    function onBoardCellClick(x, y) {
      // Если выбрана карта – обрабатываем выбор цели для карты
      if (selectedCard !== null) {
        if (selectedCard.name === "Стальной Щит") {
          let p = game.board.grid[y][x];
          if (p && p.player.id === getCurrentPlayer().id) {
            game.useCard(getCurrentPlayer(), selectedCardIndex, p);
            selectedCard = null;
            updateUI();
          } else {
            logMessage("Выберите свою фигуру для «Стального Щита».");
          }
        } else if (selectedCard.name === "Острый Клинок") {
          let p = game.board.grid[y][x];
          if (p && p.player.id !== getCurrentPlayer().id) {
            game.useCard(getCurrentPlayer(), selectedCardIndex, p);
            selectedCard = null;
            updateUI();
          } else {
            logMessage("Выберите вражескую фигуру для «Острого Клинка».");
          }
        } else if (selectedCard.name === "Теневой Манёвр") {
          let p = game.board.grid[y][x];
          if (p && p.player.id === getCurrentPlayer().id) {
            game.useCard(getCurrentPlayer(), selectedCardIndex, p);
            selectedCard = null;
            updateUI();
          } else {
            logMessage("Выберите свою фигуру для «Теневого Манёвра».");
          }
        } else if (selectedCard.name === "Смена Позиции") {
          if (!cardTargetData.firstPiece) {
            let p = game.board.grid[y][x];
            if (p) {
              cardTargetData.firstPiece = p;
              logMessage("Первая фигура выбрана. Выберите вторую фигуру для «Смены Позиции».");
            } else {
              logMessage("Выберите клетку с фигурой.");
            }
          } else {
            let p = game.board.grid[y][x];
            if (p && p !== cardTargetData.firstPiece) {
              cardTargetData.secondPiece = p;
              game.useCard(getCurrentPlayer(), selectedCardIndex, { piece1: cardTargetData.firstPiece, piece2: p });
              selectedCard = null;
              cardTargetData = {};
              updateUI();
            } else {
              logMessage("Выберите другую фигуру для «Смены Позиции».");
            }
          }
        } else if (selectedCard.name === "Пламенный Взрыв") {
          let p = game.board.grid[y][x];
          if (p) {
            game.useCard(getCurrentPlayer(), selectedCardIndex, p);
            selectedCard = null;
            updateUI();
          } else {
            logMessage("Выберите клетку с фигурой для «Пламенного Взрыва».");
          }
        } else if (selectedCard.name === "Ледяное Зачарование") {
          let p = game.board.grid[y][x];
          if (p && p.player.id !== getCurrentPlayer().id) {
            game.useCard(getCurrentPlayer(), selectedCardIndex, p);
            selectedCard = null;
            updateUI();
          } else {
            logMessage("Выберите вражескую фигуру для «Ледяного Зачарования».");
          }
        } else if (selectedCard.name === "Светлая Аура") {
          let p = game.board.grid[y][x];
          if (p && p.player.id === getCurrentPlayer().id) {
            game.useCard(getCurrentPlayer(), selectedCardIndex, p);
            selectedCard = null;
            updateUI();
          } else {
            logMessage("Выберите свою фигуру для «Светлой Ауры».");
          }
        } else if (selectedCard.name === "Вспышка Молнии") {
          if (!cardTargetData.piece) {
            let p = game.board.grid[y][x];
            if (p && p.player.id === getCurrentPlayer().id) {
              cardTargetData.piece = p;
              logMessage("Фигура выбрана. Теперь выберите пустую клетку для перемещения.");
            } else {
              logMessage("Выберите свою фигуру для «Вспышки Молнии».");
            }
          } else {
            if (game.board.grid[y][x] === null) {
              cardTargetData.destination = { x, y };
              game.useCard(getCurrentPlayer(), selectedCardIndex, { piece: cardTargetData.piece, destination: cardTargetData.destination });
              selectedCard = null;
              cardTargetData = {};
              updateUI();
            } else {
              logMessage("Выберите пустую клетку для перемещения.");
            }
          }
        } else {
          // Остальные карты (если вдруг)
          game.useCard(getCurrentPlayer(), selectedCardIndex, null);
          selectedCard = null;
          updateUI();
        }
        return;
      }
      
      // Если не выбрана карта – обрабатываем перемещение фигуры
      if (!selectedMoveSource) {
        let piece = game.board.grid[y][x];
        if (piece && piece.player.id === getCurrentPlayer().id) {
          selectedMoveSource = {
            piece: piece,
            from: { x, y },
            moves: getValidMoves(piece, game.board)
          };
          clearHighlights();
          // Подсветка выбранной клетки и допустимых ходов
          highlightCell(x, y, "selected");
          selectedMoveSource.moves.forEach(m => {
            highlightCell(m.x, m.y, "move-hint");
          });
          logMessage(`Выбрана фигура ${piece.type}. Выберите клетку для хода.`);
        } else {
          logMessage("Выберите свою фигуру для перемещения.");
        }
      } else {
        // Если уже выбрана фигура для хода, проверяем, входит ли выбранная клетка в список допустимых ходов
        let valid = selectedMoveSource.moves.some(m => m.x === x && m.y === y);
        if (valid) {
          game.movePiece(selectedMoveSource.from.x, selectedMoveSource.from.y, x, y);
          selectedMoveSource = null;
          clearHighlights();
          updateUI();
        } else {
          logMessage("Неверный ход, попробуйте снова.");
          selectedMoveSource = null;
          clearHighlights();
        }
      }
    }

    // ================== Инициализация ==================
    window.onload = function() {
      createBoardUI();
      const player1 = new Player(1, "Alice");
      const player2 = new Player(2, "Bob");
      game = new Game(player1, player2);
      game.start();
      updateUI();
    };
  </script>
</body>
</html>
