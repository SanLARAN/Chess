<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>–®–∞—Ö–º–∞—Ç—ã —Å –ö–∞—Ä—Ç–∞–º–∏</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard.js/1.0.0/css/chessboard.min.css">
  <style>
    body {
      font-family: sans-serif;
      background: #eee;
      text-align: center;
      padding: 20px;
    }

    #board {
      width: 400px;
      margin: 0 auto 20px;
    }

    #status {
      font-weight: bold;
      margin-bottom: 10px;
    }

    button {
      margin: 5px;
      padding: 10px 20px;
      font-size: 16px;
    }

    .hand {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-top: 20px;
    }

    .card {
      border: 2px solid #333;
      background: #fff;
      padding: 10px;
      border-radius: 8px;
      width: 150px;
      cursor: pointer;
      transition: 0.2s;
    }

    .card:hover {
      background-color: #f0f0f0;
    }

    .selected-card {
      border-color: red;
    }
  </style>
</head>
<body>

  <h2>‚ôüÔ∏è –®–∞—Ö–º–∞—Ç—ã —Å –ö–∞—Ä—Ç–∞–º–∏</h2>
  <div id="board"></div>
  <div id="status">–•–æ–¥ –±–µ–ª—ã—Ö</div>
  <button onclick="drawCard()">–í–∑—è—Ç—å –∫–∞—Ä—Ç—É</button>

  <div class="hand" id="hand"></div>

  <!-- chess.js –∏ chessboard.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard.js/1.0.0/js/chessboard.min.js"></script>

  <script>
    const game = new Chess();
    let currentTurn = 'w';
    let extraMove = false;
    let selectedCardIndex = null;
    let cardTargetStep = 0;
    let cardTargetData = [];

    const playerState = {
      hand: [],
      frozenPieces: {}
    };

    const cardPool = [
      {
        id: "freeze",
        name: "‚ùÑ –ó–∞–º–æ—Ä–æ–∑–∫–∞",
        description: "–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∏–≥—É—Ä—É –≤—Ä–∞–≥–∞ ‚Äî –æ–Ω–∞ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç —Ö–æ–¥.",
        effect: (square) => {
          playerState.frozenPieces[square] = 1;
          alert(`–§–∏–≥—É—Ä–∞ –Ω–∞ ${square} –∑–∞–º–æ—Ä–æ–∂–µ–Ω–∞ –Ω–∞ 1 —Ö–æ–¥!`);
        }
      },
      {
        id: "teleport",
        name: "üåÄ –¢–µ–ª–µ–ø–æ—Ä—Ç",
        description: "–í—ã–±–µ—Ä–∏—Ç–µ —Å–≤–æ—é —Ñ–∏–≥—É—Ä—É –∏ —Å–≤–æ–±–æ–¥–Ω—É—é –∫–ª–µ—Ç–∫—É –¥–ª—è —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞.",
        effect: ([from, to]) => {
          const piece = game.get(from);
          if (!piece || piece.color !== currentTurn) {
            alert("–í—ã–±–µ—Ä–∏—Ç–µ —Å–≤–æ—é —Ñ–∏–≥—É—Ä—É.");
            return;
          }
          if (game.get(to)) {
            alert("–ö–ª–µ—Ç–∫–∞ –∑–∞–Ω—è—Ç–∞.");
            return;
          }
          game.remove(from);
          game.put(piece, to);
          board.position(game.fen());
        }
      },
      {
        id: "double_move",
        name: "‚ö° –î–≤–æ–π–Ω–æ–π —Ö–æ–¥",
        description: "–°–¥–µ–ª–∞–π—Ç–µ –µ—â—ë –æ–¥–∏–Ω —Ö–æ–¥.",
        effect: () => {
          extraMove = true;
          alert("–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Ö–æ–¥ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω!");
        }
      }
    ];

    const board = Chessboard('board', {
      draggable: true,
      position: 'start',
      onDrop: onDrop,
      onSquareClick: onSquareClick
    });

    function onDrop(source, target) {
      if (playerState.frozenPieces[source]) {
        alert("–≠—Ç–∞ —Ñ–∏–≥—É—Ä–∞ –∑–∞–º–æ—Ä–æ–∂–µ–Ω–∞.");
        return 'snapback';
      }

      const move = game.move({ from: source, to: target, promotion: 'q' });
      if (move === null) return 'snapback';

      updateStatus();

      if (!extraMove) switchTurn();
      else extraMove = false;

      board.position(game.fen());
    }

    function switchTurn() {
      currentTurn = currentTurn === 'w' ? 'b' : 'w';

      for (const square in playerState.frozenPieces) {
        playerState.frozenPieces[square]--;
        if (playerState.frozenPieces[square] <= 0)
          delete playerState.frozenPieces[square];
      }

      updateStatus();
    }

    function updateStatus() {
      const status = document.getElementById("status");
      if (game.game_over()) {
        status.textContent = "–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞.";
      } else {
        status.textContent = `–•–æ–¥ ${currentTurn === 'w' ? '–±–µ–ª—ã—Ö' : '—á—ë—Ä–Ω—ã—Ö'}`;
      }
    }

    function drawCard() {
      const card = JSON.parse(JSON.stringify(cardPool[Math.floor(Math.random() * cardPool.length)]));
      playerState.hand.push(card);
      renderHand();
    }

    function renderHand() {
      const hand = document.getElementById("hand");
      hand.innerHTML = "";
      playerState.hand.forEach((card, index) => {
        const el = document.createElement("div");
        el.className = "card" + (index === selectedCardIndex ? " selected-card" : "");
        el.innerHTML = `<b>${card.name}</b><br><small>${card.description}</small>`;
        el.onclick = () => selectCard(index);
        hand.appendChild(el);
      });
    }

    function selectCard(index) {
      if (selectedCardIndex === index) {
        selectedCardIndex = null;
        cardTargetStep = 0;
        cardTargetData = [];
      } else {
        selectedCardIndex = index;
        cardTargetStep = 0;
        cardTargetData = [];
      }
      renderHand();
    }

    function onSquareClick(square) {
      if (selectedCardIndex === null) return;
      const card = playerState.hand[selectedCardIndex];

      // –ü—Ä–æ—Å—Ç—ã–µ –∫–∞—Ä—Ç—ã —Å –æ–¥–Ω–æ–π —Ü–µ–ª—å—é
      if (card.id === "freeze") {
        card.effect(square);
        playerState.hand.splice(selectedCardIndex, 1);
        selectedCardIndex = null;
        renderHand();
        return;
      }

      // –°–ª–æ–∂–Ω—ã–µ –∫–∞—Ä—Ç—ã —Å –¥–≤—É–º—è —Ü–µ–ª—è–º–∏
      if (card.id === "teleport") {
        cardTargetData.push(square);
        cardTargetStep++;
        if (cardTargetStep === 2) {
          card.effect(cardTargetData);
          playerState.hand.splice(selectedCardIndex, 1);
          selectedCardIndex = null;
          cardTargetStep = 0;
          cardTargetData = [];
          renderHand();
        }
        return;
      }

      if (card.id === "double_move") {
        card.effect();
        playerState.hand.splice(selectedCardIndex, 1);
        selectedCardIndex = null;
        renderHand();
      }
    }

    updateStatus();
  </script>
</body>
</html>
